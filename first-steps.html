<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>First Steps - Iced 中文教程 — Rust跨平台GUI库</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Iced 中文教程 — Rust跨平台GUI库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xiao-VoV/Iced_book_Chinese_pub" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/Xiao-VoV/Iced_book_Chinese_pub/edit/master/src/first-steps.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="first-steps"><a class="header" href="#first-steps">First Steps</a></h1>
<p>But enough with the theory. It’s about time we start writing some code!</p>
<p>iced embraces The Elm Architecture as the most natural approach for architecting interactive applications.
Therefore, when using iced, we will be dealing with the four main ideas we introduced in the previous chapter:
<strong>state</strong>, <strong>messages</strong>, <strong>update logic</strong>, and <strong>view logic</strong>.</p>
<p>In the previous chapter, we dissected and studied the classical counter interface. Let’s try to
build it in Rust while leveraging The Elm Architecture.</p>
<div align="center">
  <img alt="A classical counter interface" src="resources/counter-interface-annotated.svg">
</div>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>Let’s start with the <strong>state</strong>—the underlying data of the application.</p>
<p>In Rust, given the ownership and borrowing rules, it is extremely important to think carefully about the data model
of your application.</p>
<blockquote>
<p>I encourage you to always start by pondering about the data of your application and
its different states—not only those that are possible, but also those that must be impossible. Then try to leverage
the type system as much as you can to <em><a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Make Impossible States Impossible</a></em>.</p>
</blockquote>
<p>For our counter interface, all we need is a counter value. Since we have both increment and decrement interactions,
the number could potentially be negative. This means we need a signed integer.</p>
<p>Also, we know some users are crazy and they may want to count a lot of things. Let’s give them 64 bits to play with:</p>
<pre><code class="language-rust">struct Counter {
    value: i64,
}</code></pre>
<p>If a crazy user counted 1000 things every second, it would take them ~300 million years to run out of numbers.
Let’s hope that’s enough.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>Next, we need to define our <strong>messages</strong>—the interactions of the application.</p>
<p>Our counter interface has two interactions: <strong>increment</strong> and <strong>decrement</strong>. Technically, we could use a simple boolean to
encode these interactions: <code>true</code> for increment and <code>false</code> for decrement, for instance.</p>
<p>But… we can do better in Rust! Interactions are mutually exclusive—when we have an interaction, what we really have is one
value of a possible set of values. It turns out that Rust has the perfect data type for modeling this kind of idea: the <em>enum</em>.</p>
<p>Thus, we can define our messages like this:</p>
<pre><code class="language-rust">enum Message {
    Increment,
    Decrement,
}</code></pre>
<p>Simple enough! This also sets us up for the long-term. If we ever wanted to add additional interactions to our application—like a
<code>Reset</code> interaction, for instance—we could just introduce additional variants to this type. Enums are very powerful and convenient.</p>
<h2 id="update-logic"><a class="header" href="#update-logic">Update Logic</a></h2>
<p>Now, it’s time for our <strong>update logic</strong>—how messages change the state of the application.</p>
<p>Basically, we need to write some logic that given any message can update any state of the application accordingly. The simplest
and most idiomatic way to express this logic in Rust is by defining a method named <code>update</code> in our application state.</p>
<p>For our counter interface, we only need to properly increment or decrement the <code>value</code> of our <code>Counter</code> struct based on the <code>Message</code>
we just defined:</p>
<pre><code class="language-rust ignore">impl Counter {
    fn update(&amp;mut self, message: Message) {
        match message {
            Message::Increment =&gt; {
                self.value += 1;
            }
            Message::Decrement =&gt; {
                self.value -= 1;
            }
        }
    }
}</code></pre>
<p>Great! Now we are ready to process user interactions. For instance, imagine we initialized our counter like this:</p>
<pre><code class="language-rust ignore">let mut counter = Counter { value: 0 };</code></pre>
<p>And let’s say we wanted to simulate a user playing with our interface for a bit—pressing the increment button twice
and then the decrement button once. We could easily compute the final state of our counter with our <strong>update logic</strong>:</p>
<pre><code class="language-rust ignore">counter.update(Message::Increment);
counter.update(Message::Increment);
counter.update(Message::Decrement);</code></pre>
<p>This would cause our <code>Counter</code> to end up with a <code>value</code> of <code>1</code>:</p>
<pre><code class="language-rust ignore">assert_eq!(counter.value, 1);</code></pre>
<p>In fact, we have just written a simple test for our application logic:</p>
<pre><code class="language-rust ignore">#[test]
fn it_counts_properly() {
    let mut counter = Counter { value: 0 };

    counter.update(Message::Increment);
    counter.update(Message::Increment);
    counter.update(Message::Decrement);

    assert_eq!(counter.value, 1);
}</code></pre>
<p>Notice how easy this was to write! So far, we are just leveraging very simple Rust concepts. No dependencies in sight!
You may even be wondering… “Where is the GUI code?!”</p>
<p>This is one of the main advantages of The Elm Architecture. As we discovered in the previous chapter, widgets are the
only fundamental idea of an interface that is reusable in nature. All the parts we have defined so far are application-specific
and, therefore, do not need to know about the UI library at all!</p>
<p>The Elm Architecture properly embraces the different nature of each part of a user interface—decoupling <strong>state</strong>,
<strong>messages</strong>, and <strong>update logic</strong> from <strong>widgets</strong> and <strong>view logic</strong>.</p>
<h2 id="view-logic"><a class="header" href="#view-logic">View Logic</a></h2>
<p>Finally, the only part left for us to define is our <strong>view logic</strong>—how state dictates the widgets of the application.</p>
<p>Here is where the magic happens! In view logic, we bring together the state of the application and its possible interactions
to produce a visual representation of the user interface that must be displayed to the user.</p>
<div align="center" class="right">
  <img alt="A classical counter interface" src="resources/counter-interface.svg" width="50%">
</div>
<p>As we have already learned, this visual representation is made of widgets—the visibly distinct units of an interface. Most
widgets are not application-specific and they can be abstracted and packaged into reusable libraries. These libraries are
normally called <em>widget toolkits</em>, <em>GUI frameworks</em>, or simply <em>GUI libraries</em>.</p>
<p>And this is where <strong>iced</strong> comes in—finally! iced is a cross-platform GUI library for Rust. It packages a fair collection of
ready-to-use widgets; buttons and numbers included. Exactly what we need for our counter.</p>
<h3 id="the-buttons"><a class="header" href="#the-buttons">The Buttons</a></h3>
<p>Our counter interface has two <strong>buttons</strong>. Let’s see how we can define them using iced.</p>
<p>In iced, widgets are independent values. The same way you can have an integer in a variable, you can have a widget as well.
These values are normally created using a <em>helper function</em> from the <code>widget</code> module.</p>
<p>For our buttons, we can use the <code>button</code> helper:</p>
<pre><code class="language-rust ignore">use iced::widget::button;

let increment = button("+");
let decrement = button("-");</code></pre>
<p>That’s quite simple, isn’t it? For now, we have just defined a couple of variables for our buttons.</p>
<p>As we can see, widget helpers may take arguments for configuring parts of the widgets to our liking.
In this case, the <code>button</code> function takes a single argument used to describe the contents of the button.</p>
<h3 id="the-number"><a class="header" href="#the-number">The Number</a></h3>
<p>We have our buttons sitting nicely in our <code>increment</code> and <code>decrement</code> variables. How about we do the same
for our counter value?</p>
<p>While iced does not really have a <code>number</code> widget, it does have a more generic <code>text</code> widget that can be used
to display any kind of text—numbers included:</p>
<pre><code class="language-rust ignore">use iced::widget::text;

let counter = text(15);</code></pre>
<p>Sweet! Like <code>button</code>, <code>text</code> also takes an argument used to describe its contents. Since we are just getting started, let’s
simply hardcode <code>15</code> for now.</p>
<h3 id="the-layout"><a class="header" href="#the-layout">The Layout</a></h3>
<p>Alright! We have our two buttons in <code>increment</code> and <code>decrement</code>, and our counter value in <code>counter</code>. That should be everything, right?</p>
<p>Not so fast! The widgets in our counter interface are displayed in a specific <strong>order</strong>. Given our three widgets, there is a total of
<strong>six</strong> different ways to order them. However, the order we want is: <code>increment</code>, <code>counter</code>, and <code>decrement</code>.</p>
<p>A very simple way of describing this order is to create a list with our widgets:</p>
<pre><code class="language-rust ignore">let interface = vec![increment, counter, decrement];</code></pre>
<p>But we are still missing something! It’s not only the order that is specific, our interface also has a specific visual <strong>layout</strong>.</p>
<p>The widgets are positioned on top of each other, but they could very well be positioned from left to right instead. There is nothing
in our description so far that talks about the <strong>layout</strong> of our widgets.</p>
<p>In iced, layout is described using… well, more widgets! That’s right. Not all widgets produce visual results directly; some may simply
manage the position of existing widgets. And since widgets are just values, they can be nested and composed nicely.</p>
<p>The kind of vertical layout that we need for our counter can be achieved with the <code>column</code> widget:</p>
<pre><code class="language-rust ignore">use iced::widget::column;

let interface = column![increment, counter, decrement];</code></pre>
<p>This is very similar to our previous snippet. iced provides a <code>column!</code> macro for creating a <code>column</code> out of some widgets in a particular
<strong>order</strong>—analogous to <code>vec!</code>.</p>
<h3 id="the-interactions"><a class="header" href="#the-interactions">The Interactions</a></h3>
<p>At this point, we have in our <code>interface</code> variable a <code>column</code> representing our counter interface. But if we actually tried to run it,
we would quickly find out that something is wrong.</p>
<p>Our buttons would be completely disabled. Of course! We have not defined any <strong>interactions</strong> for them. Notice that we have yet
to use our <code>Message</code> enum in our view logic. How is our user interface supposed to produce <strong>messages</strong> if we don’t specify
them? Let’s do that now.</p>
<p>In iced, every widget has a specific type that enables further configuration using simple builder methods. The <code>button</code>
helper returns an instance of <a href="https://docs.rs/iced/0.12.1/iced/widget/struct.Button.html">the <code>Button</code> type</a>, which has an <code>on_press</code> method we can use to define the message it must
<strong>produce</strong> when a user presses the button:</p>
<pre><code class="language-rust ignore">use iced::widget::button;

let increment = button("+").on_press(Message::Increment);
let decrement = button("-").on_press(Message::Decrement);</code></pre>
<p>Awesome! Our interactions are wired up. But there is still a small detail left. A button can be pressed multiple times. Therefore,
the same button may need to produce multiple instances of the same <code>Message</code>. As a result, we need our <code>Message</code> type to be cloneable.</p>
<p>We can easily <em>derive</em> the <code>Clone</code> trait—as well as <code>Debug</code> and <code>Copy</code> for good measure:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy)]
enum Message {
    Increment,
    Decrement,
}</code></pre>
<p>In The Elm Architecture, messages represent <strong>events</strong> that have occurred—made of pure data. As a consequence, it should always be easy
to derive <code>Debug</code> and <code>Clone</code> for our <code>Message</code> type.</p>
<h3 id="the-view"><a class="header" href="#the-view">The View</a></h3>
<p>We are almost there! There is only one thing left to do: connecting our application <strong>state</strong> to the view logic.</p>
<p>Let’s bring together all the view logic we have written so far:</p>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text};

// The buttons
let increment = button("+").on_press(Message::Increment);
let decrement = button("-").on_press(Message::Decrement);

// The number
let counter = text(15);

// The layout
let interface = column![increment, counter, decrement];</code></pre>
<p>If we ran this view logic, we would now be able to press the buttons. However, nothing would happen as a result. The
counter would be stuck—always showing the number <code>15</code>. Our interface is completely stateless!</p>
<p>Obviously, the issue here is that our <code>counter</code> variable contains a text widget with a hardcoded <code>15</code>. Instead, what
we want is to actually display the <code>value</code> field of our <code>Counter</code> state. This way, when a button is pressed and
our update logic is triggered, the text widget will display the new <code>value</code>.</p>
<p>We can easily do this by running our view logic in a method of our <code>Counter</code>—just like we did with our update logic:</p>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text};

impl Counter {
    fn view(&amp;self) {
        // The buttons
        let increment = button("+").on_press(Message::Increment);
        let decrement = button("-").on_press(Message::Decrement);

        // The number
        let counter = text(self.value);

        // The layout
        let interface = column![increment, counter, decrement];
    }
}</code></pre>
<p>Our <code>counter</code> variable now will always have a <code>text</code> widget with the current <code>value</code> of our <code>Counter</code>. Great!</p>
<p>However, and as you may have noticed, this <code>view</code> method is completely useless—it constructs an
<code>interface</code>, but then… It does nothing with it and throws it away!</p>
<blockquote>
<p>In iced, constructing and configuring widgets has no side effects. There is no “global context” you need to
worry about in your view code.</p>
</blockquote>
<p>Instead of throwing the <code>interface</code> away, we need to return it. Remember, the purpose of our <strong>view logic</strong> is
to dictate the widgets of our user interface; and the content of the <code>interface</code> variable is precisely the
description of the interface we want:</p>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text, Column};

impl Counter {
    fn view(&amp;self) -&gt; Column&lt;Message&gt; {
        // The buttons
        let increment = button("+").on_press(Message::Increment);
        let decrement = button("-").on_press(Message::Decrement);

        // The number
        let counter = text(self.value);

        // The layout
        let interface = column![increment, counter, decrement];

        interface
    }
}</code></pre>
<p>Tada! Notice how the <code>view</code> method needs a return type now. The returned type is <code>Column</code> because the <code>column!</code> macro produces
a widget of this type—just like <code>button</code> produces a widget of the <code>Button</code> type.</p>
<p>You may also have noticed that this <code>Column</code> type has a generic type parameter. This type parameter simply specifies the type
of messages the widget may produce. In this case, it takes our <code>Message</code> because the <code>increment</code> and <code>decrement</code> buttons inside
the column produce messages of this type.</p>
<blockquote>
<p>iced has a strong focus on type safety—leveraging the type system and compile-time guarantees to minimize runtime errors
as much as possible.</p>
</blockquote>
<p>And well… That’s it! Our view logic is done! But wait… It’s a bit verbose right now. Since it’s such a simple interface,
let’s just inline everything:</p>
<div align="center" class="right">
  <img alt="A classical counter interface" src="resources/counter-interface.svg" width="50%">
</div>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text, Column};

impl Counter {
    fn view(&amp;self) -&gt; Column&lt;Message&gt; {
        column![
            button("+").on_press(Message::Increment),
            text(self.value),
            button("-").on_press(Message::Decrement),
        ]
    }
}</code></pre>
<p>That’s much more concise. It even resembles the actual interface! Since creating widgets just yields values with no
side effects; we can move things around in our view logic without worrying about breaking other stuff. No spooky
action at a distance!</p>
<p>And that’s all there is to our counter interface. I am sure you can’t wait to <strong>run</strong> it. Shall we?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="architecture.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="the-runtime.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="architecture.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="the-runtime.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
