<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Iced 中文教程 — Rust跨平台GUI库</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Iced 中文教程 — Rust跨平台GUI库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xiao-VoV/Iced_book_Chinese_pub" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div align="center">
  <img alt="iced 标志" src="../resources/logo.svg" width="140">
</div>
<h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p><a href="https://iced.rs">iced</a> 是一个用于 <a href="https://rust-lang.org">Rust</a> 的跨平台 GUI 库。它受到 <a href="https://elm-lang.org">Elm</a> 的启发，Elm 是一种用于构建 Web 应用程序的令人愉悦的函数式语言。</p>
<p>作为一个 GUI 库，iced 帮助您为 Rust 应用程序构建<a href="https://en.wikipedia.org/wiki/Graphical_user_interface">图形用户界面</a>。</p>
<p>iced 强烈专注于<strong>简洁性</strong>和<strong>类型安全</strong>。因此，iced 试图提供简单的构建块，这些构建块可以通过强类型组合在一起，以减少<strong>运行时错误</strong>的可能性。</p>
<p>本书将：</p>
<ul>
<li>向您介绍 iced 的基本思想。</li>
<li>教您如何使用 iced 构建交互式应用程序。</li>
<li>强调扩展和发展 iced 应用程序的原则。</li>
</ul>
<p>在继续之前，您应该对 Rust 有一些基本的了解。如果您是 Rust 新手或在某些时候感到困惑，我建议您阅读<a href="https://doc.rust-lang.org/book/">官方 Rust 书籍</a>。</p>
<p>本文档是iced文档的中文翻译，由Claude辅助翻译，部分章节正在校对中，有任何问题欢迎指正。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="架构"><a class="header" href="#架构">架构</a></h1>
<p>让我们从基础开始！您可能已经非常熟悉图形用户界面了。
您可以在手机、计算机和大多数交互式电子设备上找到它们。事实上，您很可能正在使用一个来阅读这本书！</p>
<p>从本质上讲，图形用户界面是向用户图形化<strong>显示</strong>一些信息的应用程序。然后用户可以选择与应用程序<strong>交互</strong>——通常使用某种设备；比如键盘、鼠标或触摸屏。</p>
<div align="center">
  <img alt="界面显示，用户交互" src="../resources/gui-displays-user-interacts.svg">
</div>
<p>用户交互可能导致应用程序更新并因此显示新信息，这反过来可能导致进一步的用户交互，进而导致进一步的更新…等等。这种快速的反馈循环是产生<em>交互性</em>感觉的原因。</p>
<blockquote>
<p>注意：在本书中，我们将图形用户界面称为 <strong>GUI</strong>、<strong>UI</strong>、<strong>用户界面</strong>或简称<strong>界面</strong>。从技术上讲，并非所有界面都是图形化的或面向用户的；但是，考虑到本书的上下文，我们将交替使用所有这些术语。</p>
</blockquote>
<h2 id="剖析界面"><a class="header" href="#剖析界面">剖析界面</a></h2>
<p>由于我们有兴趣创建用户界面，让我们仔细看看它们。我们将从一个非常简单的开始：经典的计数器界面。它由什么组成？</p>
<div align="center">
  <img alt="经典计数器界面" src="../resources/counter-interface.svg">
</div>
<p>正如我们可以清楚地看到的，这个界面有三个视觉上不同的元素：两个按钮中间有一个数字。我们将用户界面的这些视觉上不同的元素称为<strong>组件</strong>或<strong>元素</strong>。</p>
<p>一些<strong>组件</strong>可能是交互式的，比如按钮。在计数器界面中，按钮可以用来触发某些<strong>交互</strong>。具体来说，顶部的按钮可以用来增加计数器值，而底部的按钮可以用来减少它。</p>
<p>我们也可以说用户界面是<em>有状态的</em>——有一些<strong>状态</strong>在交互之间持续存在。计数器界面显示一个表示计数器值的数字。显示的数字将根据我们按按钮的次数而改变。按一次增加按钮将导致与按两次不同的显示值。</p>
<div align="center">
  <img alt="剖析的计数器界面" src="../resources/counter-interface-annotated.svg">
</div>
<h2 id="gui-三要素"><a class="header" href="#gui-三要素">GUI 三要素</a></h2>
<p>我们的快速剖析成功识别了用户界面中的三个基本思想：</p>
<ul>
<li><strong>组件</strong> — 界面的不同视觉元素。</li>
<li><strong>交互</strong> — 可能由某些组件触发的动作。</li>
<li><strong>状态</strong> — 界面的底层条件或信息。</li>
</ul>
<p>这些思想相互连接，形成另一个反馈循环！</p>
<p><strong>组件</strong>在用户与它们交互时产生<strong>交互</strong>。这些<strong>交互</strong>然后改变界面的<strong>状态</strong>。改变的<strong>状态</strong>传播并决定必须显示的新<strong>组件</strong>。这些新<strong>组件</strong>然后可能产生新的<strong>交互</strong>，这可以再次改变<strong>状态</strong>…等等。</p>
<div align="center">
  <img alt="GUI 三要素" src="../resources/the-gui-trinity.svg">
</div>
<p>这些思想及其连接构成了用户界面的基本架构。因此，创建用户界面必然包括定义这些<strong>组件</strong>、<strong>交互</strong>和<strong>状态</strong>；以及它们之间的连接。</p>
<h2 id="不同的思想不同的性质"><a class="header" href="#不同的思想不同的性质">不同的思想，不同的性质</a></h2>
<p>界面的三个基本思想在可重用性方面差异很大。</p>
<p>界面的状态和交互对应用程序及其目的非常特定。如果我告诉您我有一个具有数值和增加和减少交互的界面，您很容易猜到我在谈论计数器界面。</p>
<p>然而，如果我告诉您我有一个具有两个按钮和一个数字的界面…您猜测我在谈论什么样的界面就相当困难了。它可能是任何东西！</p>
<p>这是因为组件通常非常通用，因此更可重用。大多数界面显示熟悉组件的组合——比如按钮和数字。事实上，用户期望熟悉的组件总是以某种方式行为。如果它们行为不当，界面将不直观并具有糟糕的<a href="https://en.wikipedia.org/wiki/User_experience">用户体验</a>。</p>
<p>虽然组件通常非常可重用；但由应用程序状态及其交互决定的特定组件配置是非常特定于应用程序的。按钮是通用的；但具有“+“标签并在按下时导致值增加的按钮是非常特定的。</p>
<p>所有这些意味着，当我们创建特定的用户界面时，我们不想专注于实现每个熟悉的组件及其行为。相反，我们想要利用组件作为可重用的构建块——独立于我们的应用程序并由某个库提供——同时将我们的重点放在基本架构的应用程序特定部分：状态、交互、交互如何改变状态，以及状态如何决定组件。</p>
<div align="center">
  <img alt="GUI 的应用程序特定部分" src="../resources/the-gui-trinity-focused.svg">
</div>
<h2 id="elm-架构"><a class="header" href="#elm-架构">Elm 架构</a></h2>
<p>事实证明，界面架构的四个应用程序特定部分也是<a href="https://guide.elm-lang.org/architecture/">Elm 架构</a>的四个基本思想。</p>
<blockquote>
<p>Elm 架构是一种用于构建交互式程序的模式，它在 <a href="https://elm-lang.org/">Elm</a> 中自然出现，Elm 是一种用于可靠 Web 应用程序的令人愉悦的纯函数式编程语言。</p>
<p>在纯函数式编程语言中出现的模式和思想在 Rust 中往往工作得很好，因为它们利用了不可变性和<a href="https://en.wikipedia.org/wiki/Referential_transparency">引用透明性</a>——这两个非常理想的属性不仅使代码易于推理，而且与借用检查器配合得很好。</p>
<p>此外，Elm 架构不仅在 Elm 中自然出现，而且在简单地剖析用户界面并形式化其内部工作时也会出现；就像我们刚才在本章中所做的那样。</p>
</blockquote>
<p>Elm 架构为其基本部分使用不同的——如果不是更精确的——命名法：</p>
<ul>
<li><strong>模型</strong> — 应用程序的状态。</li>
<li><strong>消息</strong> — 应用程序的交互。</li>
<li><strong>更新逻辑</strong> — 消息如何改变状态。</li>
<li><strong>视图逻辑</strong> — 状态如何决定组件。</li>
</ul>
<p>这些是不同的名称，但它们指向我们已经发现的完全相同的基本思想，因此可以互换使用。</p>
<div align="center">
  <img alt="Elm 架构" src="../resources/the-elm-architecture.svg">
</div>
<blockquote>
<p>注意：在 iced 中，<strong>状态</strong>和<strong>消息</strong>这些名称比<strong>模型</strong>和<strong>交互</strong>使用得更频繁。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一步"><a class="header" href="#第一步">第一步</a></h1>
<p>但是理论已经够了。是时候开始写一些代码了！</p>
<p>iced 采用 Elm 架构作为构建交互式应用程序最自然的方法。
因此，在使用 iced 时，我们将处理上一章中介绍的四个主要思想：
<strong>状态</strong>、<strong>消息</strong>、<strong>更新逻辑</strong>和<strong>视图逻辑</strong>。</p>
<p>在上一章中，我们剖析并研究了经典的计数器界面。让我们尝试
在 Rust 中构建它，同时利用 Elm 架构。</p>
<div align="center">
  <img alt="经典计数器界面" src="../resources/counter-interface-annotated.svg">
</div>
<h2 id="状态"><a class="header" href="#状态">状态</a></h2>
<p>让我们从<strong>状态</strong>开始——应用程序的底层数据。</p>
<p>在 Rust 中，考虑到所有权和借用规则，仔细思考应用程序的数据模型
是极其重要的。</p>
<blockquote>
<p>我鼓励您总是从思考应用程序的数据及其
不同状态开始——不仅是那些可能的，还有那些必须不可能的。然后尽可能多地利用
类型系统来_<a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">使不可能的状态变得不可能</a>_。</p>
</blockquote>
<p>对于我们的计数器界面，我们只需要一个计数器值。由于我们有增加和减少交互，
数字可能是负数。这意味着我们需要一个有符号整数。</p>
<p>另外，我们知道一些用户很疯狂，他们可能想要计算很多东西。让我们给他们 64 位来玩：</p>
<pre><code class="language-rust">struct Counter {
    value: i64,
}</code></pre>
<p>如果一个疯狂的用户每秒计算 1000 个东西，他们需要大约 3 亿年才能用完数字。
希望这就足够了。</p>
<h2 id="消息"><a class="header" href="#消息">消息</a></h2>
<p>接下来，我们需要定义我们的<strong>消息</strong>——应用程序的交互。</p>
<p>我们的计数器界面有两个交互：<strong>增加</strong>和<strong>减少</strong>。从技术上讲，我们可以使用简单的布尔值来
编码这些交互：例如，<code>true</code> 表示增加，<code>false</code> 表示减少。</p>
<p>但是…我们在 Rust 中可以做得更好！交互是互斥的——当我们有一个交互时，我们真正拥有的是一个
可能值集合中的一个值。事实证明，Rust 有完美的数据类型来建模这种思想：<em>枚举</em>。</p>
<p>因此，我们可以这样定义我们的消息：</p>
<pre><code class="language-rust">enum Message {
    Increment,
    Decrement,
}</code></pre>
<p>足够简单！这也为我们的长期发展做好了准备。如果我们想要向应用程序添加额外的交互——比如
<code>Reset</code> 交互——我们只需向这个类型引入额外的变体。枚举非常强大和方便。</p>
<h2 id="更新逻辑"><a class="header" href="#更新逻辑">更新逻辑</a></h2>
<p>现在，是时候编写我们的<strong>更新逻辑</strong>了——消息如何改变应用程序的状态。</p>
<p>基本上，我们需要编写一些逻辑，给定任何消息都可以相应地更新应用程序的任何状态。在 Rust 中表达这种逻辑的最简单
和最惯用的方法是在我们的应用程序状态中定义一个名为 <code>update</code> 的方法。</p>
<p>对于我们的计数器界面，我们只需要根据我们刚刚定义的 <code>Message</code>
正确地增加或减少我们 <code>Counter</code> 结构的 <code>value</code>：</p>
<pre><code class="language-rust ignore">impl Counter {
    fn update(&amp;mut self, message: Message) {
        match message {
            Message::Increment =&gt; {
                self.value += 1;
            }
            Message::Decrement =&gt; {
                self.value -= 1;
            }
        }
    }
}</code></pre>
<p>太好了！现在我们准备好处理用户交互了。例如，想象我们这样初始化我们的计数器：</p>
<pre><code class="language-rust ignore">let mut counter = Counter { value: 0 };</code></pre>
<p>假设我们想要模拟用户玩我们的界面一会儿——按两次增加按钮
然后按一次减少按钮。我们可以使用我们的<strong>更新逻辑</strong>轻松计算计数器的最终状态：</p>
<pre><code class="language-rust ignore">counter.update(Message::Increment);
counter.update(Message::Increment);
counter.update(Message::Decrement);</code></pre>
<p>这将导致我们的 <code>Counter</code> 最终的 <code>value</code> 为 <code>1</code>：</p>
<pre><code class="language-rust ignore">assert_eq!(counter.value, 1);</code></pre>
<p>事实上，我们刚刚为我们的应用程序逻辑编写了一个简单的测试：</p>
<pre><code class="language-rust ignore">#[test]
fn it_counts_properly() {
    let mut counter = Counter { value: 0 };

    counter.update(Message::Increment);
    counter.update(Message::Increment);
    counter.update(Message::Decrement);

    assert_eq!(counter.value, 1);
}</code></pre>
<p>注意这写起来多么容易！到目前为止，我们只是利用了非常简单的 Rust 概念。没有依赖项！
您甚至可能想知道…“GUI 代码在哪里？！”</p>
<p>这是 Elm 架构的主要优势之一。正如我们在上一章中发现的，组件是
界面中唯一本质上可重用的基本思想。到目前为止我们定义的所有部分都是特定于应用程序的，
因此根本不需要了解 UI 库！</p>
<p>Elm 架构正确地拥抱了用户界面每个部分的不同性质——将<strong>状态</strong>、
<strong>消息</strong>和<strong>更新逻辑</strong>与<strong>组件</strong>和<strong>视图逻辑</strong>解耦。</p>
<h2 id="视图逻辑"><a class="header" href="#视图逻辑">视图逻辑</a></h2>
<p>最后，我们需要定义的唯一部分是我们的<strong>视图逻辑</strong>——状态如何决定应用程序的组件。</p>
<p>这就是魔法发生的地方！在视图逻辑中，我们将应用程序的状态及其可能的交互结合起来
产生必须向用户显示的用户界面的视觉表示。</p>
<div align="center" class="right">
  <img alt="经典计数器界面" src="../resources/counter-interface.svg" width="50%">
</div>
<p>正如我们已经学到的，这种视觉表示由组件组成——界面的视觉上不同的单元。大多数
组件不是特定于应用程序的，它们可以被抽象并打包到可重用的库中。这些库通常
被称为_组件工具包_、<em>GUI 框架_或简称_GUI 库</em>。</p>
<p>这就是 <strong>iced</strong> 的用武之地——终于！iced 是一个用于 Rust 的跨平台 GUI 库。它打包了相当多的
现成可用的组件；包括按钮和数字。正是我们计数器所需要的。</p>
<h3 id="按钮"><a class="header" href="#按钮">按钮</a></h3>
<p>我们的计数器界面有两个<strong>按钮</strong>。让我们看看如何使用 iced 定义它们。</p>
<p>在 iced 中，组件是独立的值。就像您可以在变量中有一个整数一样，您也可以有一个组件。
这些值通常使用 <code>widget</code> 模块中的_辅助函数_创建。</p>
<p>对于我们的按钮，我们可以使用 <code>button</code> 辅助函数：</p>
<pre><code class="language-rust ignore">use iced::widget::button;

let increment = button("+");
let decrement = button("-");</code></pre>
<p>这很简单，不是吗？现在，我们只是为我们的按钮定义了几个变量。</p>
<p>正如我们所看到的，组件辅助函数可能需要参数来配置组件的部分以符合我们的喜好。
在这种情况下，<code>button</code> 函数接受一个用于描述按钮内容的参数。</p>
<h3 id="数字"><a class="header" href="#数字">数字</a></h3>
<p>我们的按钮很好地放在我们的 <code>increment</code> 和 <code>decrement</code> 变量中。我们如何为
计数器值做同样的事情？</p>
<p>虽然 iced 实际上没有 <code>number</code> 组件，但它确实有一个更通用的 <code>text</code> 组件，可以用来
显示任何类型的文本——包括数字：</p>
<pre><code class="language-rust ignore">use iced::widget::text;

let counter = text(15);</code></pre>
<p>太好了！像 <code>button</code> 一样，<code>text</code> 也接受一个用于描述其内容的参数。由于我们刚刚开始，让我们
暂时简单地硬编码 <code>15</code>。</p>
<h3 id="布局"><a class="header" href="#布局">布局</a></h3>
<p>好的！我们在 <code>increment</code> 和 <code>decrement</code> 中有我们的两个按钮，在 <code>counter</code> 中有我们的计数器值。这应该就是一切了，对吧？</p>
<p>不要这么快！我们计数器界面中的组件以特定的<strong>顺序</strong>显示。给定我们的三个组件，总共有
<strong>六</strong>种不同的排序方式。然而，我们想要的顺序是：<code>increment</code>、<code>counter</code> 和 <code>decrement</code>。</p>
<p>描述这种顺序的一个非常简单的方法是创建一个包含我们组件的列表：</p>
<pre><code class="language-rust ignore">let interface = vec![increment, counter, decrement];</code></pre>
<p>但我们仍然缺少一些东西！不仅顺序是特定的，我们的界面还有特定的视觉<strong>布局</strong>。</p>
<p>组件彼此堆叠，但它们也可以从左到右定位。在我们迄今为止的描述中，没有任何内容
谈论我们组件的<strong>布局</strong>。</p>
<p>在 iced 中，布局使用…嗯，更多组件来描述！没错。并非所有组件都直接产生视觉结果；有些可能只是
管理现有组件的位置。由于组件只是值，它们可以很好地嵌套和组合。</p>
<p>我们计数器需要的那种垂直布局可以通过 <code>column</code> 组件实现：</p>
<pre><code class="language-rust ignore">use iced::widget::column;

let interface = column![increment, counter, decrement];</code></pre>
<p>这与我们之前的代码片段非常相似。iced 提供了一个 <code>column!</code> 宏，用于从特定
<strong>顺序</strong>的一些组件创建 <code>column</code>——类似于 <code>vec!</code>。</p>
<h3 id="交互"><a class="header" href="#交互">交互</a></h3>
<p>此时，我们在 <code>interface</code> 变量中有一个表示我们计数器界面的 <code>column</code>。但如果我们实际尝试运行它，
我们会很快发现有些不对劲。</p>
<p>我们的按钮将完全被禁用。当然！我们还没有为它们定义任何<strong>交互</strong>。注意我们还没有
在视图逻辑中使用我们的 <code>Message</code> 枚举。如果我们不指定，我们的用户界面如何产生<strong>消息</strong>
呢？让我们现在就做。</p>
<p>在 iced 中，每个组件都有一个特定的类型，可以使用简单的构建器方法进行进一步配置。<code>button</code>
辅助函数返回<a href="https://docs.rs/iced/0.12.1/iced/widget/struct.Button.html"><code>Button</code> 类型</a>的实例，它有一个 <code>on_press</code> 方法，我们可以用它来定义当用户按下按钮时它必须
<strong>产生</strong>的消息：</p>
<pre><code class="language-rust ignore">use iced::widget::button;

let increment = button("+").on_press(Message::Increment);
let decrement = button("-").on_press(Message::Decrement);</code></pre>
<p>太棒了！我们的交互已经连接好了。但还有一个小细节。按钮可以被多次按下。因此，
同一个按钮可能需要产生同一个 <code>Message</code> 的多个实例。结果，我们需要我们的 <code>Message</code> 类型是可克隆的。</p>
<p>我们可以轻松地_派生_ <code>Clone</code> 特征——以及 <code>Debug</code> 和 <code>Copy</code> 以防万一：</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy)]
enum Message {
    Increment,
    Decrement,
}</code></pre>
<p>在 Elm 架构中，消息表示已经发生的<strong>事件</strong>——由纯数据组成。因此，为我们的 <code>Message</code> 类型派生 <code>Debug</code> 和 <code>Clone</code> 应该总是很容易的。</p>
<h3 id="视图"><a class="header" href="#视图">视图</a></h3>
<p>我们快到了！只剩下一件事要做：将我们的应用程序<strong>状态</strong>连接到视图逻辑。</p>
<p>让我们汇总到目前为止编写的所有视图逻辑：</p>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text};

// 按钮
let increment = button("+").on_press(Message::Increment);
let decrement = button("-").on_press(Message::Decrement);

// 数字
let counter = text(15);

// 布局
let interface = column![increment, counter, decrement];</code></pre>
<p>如果我们运行这个视图逻辑，我们现在能够按下按钮。然而，结果什么也不会发生。
计数器会卡住——总是显示数字 <code>15</code>。我们的界面完全是无状态的！</p>
<p>显然，这里的问题是我们的 <code>counter</code> 变量包含一个硬编码 <code>15</code> 的文本组件。相反，我们
想要的是实际显示我们 <code>Counter</code> 状态的 <code>value</code> 字段。这样，当按下按钮并
触发我们的更新逻辑时，文本组件将显示新的 <code>value</code>。</p>
<p>我们可以通过在我们的 <code>Counter</code> 的方法中运行我们的视图逻辑来轻松做到这一点——就像我们对更新逻辑所做的那样：</p>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text};

impl Counter {
    fn view(&amp;self) {
        // 按钮
        let increment = button("+").on_press(Message::Increment);
        let decrement = button("-").on_press(Message::Decrement);

        // 数字
        let counter = text(self.value);

        // 布局
        let interface = column![increment, counter, decrement];
    }
}</code></pre>
<p>我们的 <code>counter</code> 变量现在将始终有一个带有我们 <code>Counter</code> 当前 <code>value</code> 的 <code>text</code> 组件。太好了！</p>
<p>然而，正如您可能注意到的，这个 <code>view</code> 方法完全没用——它构造了一个
<code>interface</code>，但然后…它什么也不做，把它扔掉了！</p>
<blockquote>
<p>在 iced 中，构造和配置组件没有副作用。在您的视图代码中没有需要
担心的“全局上下文“。</p>
</blockquote>
<p>我们需要返回 <code>interface</code>，而不是把它扔掉。记住，我们<strong>视图逻辑</strong>的目的是
决定我们用户界面的组件；<code>interface</code> 变量的内容正是我们想要的
界面的描述：</p>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text, Column};

impl Counter {
    fn view(&amp;self) -&gt; Column&lt;Message&gt; {
        // 按钮
        let increment = button("+").on_press(Message::Increment);
        let decrement = button("-").on_press(Message::Decrement);

        // 数字
        let counter = text(self.value);

        // 布局
        let interface = column![increment, counter, decrement];

        interface
    }
}</code></pre>
<p>太棒了！注意 <code>view</code> 方法现在需要一个返回类型。返回的类型是 <code>Column</code>，因为 <code>column!</code> 宏产生
这种类型的组件——就像 <code>button</code> 产生 <code>Button</code> 类型的组件一样。</p>
<p>您可能还注意到这个 <code>Column</code> 类型有一个泛型类型参数。这个类型参数简单地指定
组件可能产生的消息类型。在这种情况下，它接受我们的 <code>Message</code>，因为列内的 <code>increment</code> 和 <code>decrement</code> 按钮
产生这种类型的消息。</p>
<blockquote>
<p>iced 强烈关注类型安全——利用类型系统和编译时保证来尽可能减少运行时错误。</p>
</blockquote>
<p>嗯…就是这样！我们的视图逻辑完成了！但等等…现在有点冗长。由于这是一个如此简单的界面，
让我们内联所有内容：</p>
<div align="center" class="right">
  <img alt="经典计数器界面" src="../resources/counter-interface.svg" width="50%">
</div>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text, Column};

impl Counter {
    fn view(&amp;self) -&gt; Column&lt;Message&gt; {
        column![
            button("+").on_press(Message::Increment),
            text(self.value),
            button("-").on_press(Message::Decrement),
        ]
    }
}</code></pre>
<p>这更简洁了。它甚至类似于实际的界面！由于创建组件只是产生没有
副作用的值；我们可以在视图逻辑中移动东西而不用担心破坏其他东西。没有诡异的
远距离作用！</p>
<p>这就是我们计数器界面的全部内容。我相信您迫不及待地想要<strong>运行</strong>它。我们开始吧？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运行时"><a class="header" href="#运行时">运行时</a></h1>
<p>在上一章中，我们使用 iced 和 Elm 架构构建了经典的计数器界面。我们专注于每个
基本部分——一次一个：<strong>状态</strong>、<strong>消息</strong>、<strong>更新逻辑</strong>和<strong>视图逻辑</strong>。</p>
<p>但现在怎么办？是的，我们有用户界面的所有基本部分——正如我们在
<a href="architecture.html">剖析过程中</a>学到的——但不清楚我们应该如何让它活起来。</p>
<p>看起来我们缺少_某些东西_，可以将所有部分组合在一起并让它们协调_运行_。_某些东西_可以
创建并运行用户界面的基本循环——向用户显示组件并对任何交互做出反应。</p>
<p>这个_某些东西_被称为<strong>运行时</strong>。您可以将其视为用户界面反馈循环发生的环境。运行时负责循环的每个部分：初始化<strong>状态</strong>、
产生<strong>消息</strong>、执行<strong>更新逻辑</strong>和运行我们的<strong>视图逻辑</strong>。</p>
<div align="center">
  <img alt="运行时" src="../resources/the-runtime.svg">
</div>
<blockquote>
<p>想象运行时的另一种方式是想象一个缺少四个基本部分的巨大引擎。我们的工作是
填补这些部分——然后引擎就可以运行了！</p>
</blockquote>
<h2 id="神奇的运行时"><a class="header" href="#神奇的运行时">神奇的运行时</a></h2>
<p>让我们通过探索基本（虽然非常神奇！）运行时的内部来更好地理解界面的生命周期。</p>
<p>事实上，我们实际上已经开始编写运行时了！当<a href="first-steps.html#update-logic">我们实现计数器的更新逻辑</a>时，
我们编写了一个模拟用户的非常小的测试：</p>
<pre><code class="language-rust ignore">#[test]
fn it_counts_properly() {
    let mut counter = Counter { value: 0 };

    counter.update(Message::Increment);
    counter.update(Message::Increment);
    counter.update(Message::Decrement);

    assert_eq!(counter.value, 1);
}</code></pre>
<p>从技术上讲，这是一个非常基础的运行时。它初始化<strong>状态</strong>，产生一些<strong>交互</strong>，
并执行<strong>更新逻辑</strong>。</p>
<p>当然，交互是编造的，它非常短暂，并且没有涉及<strong>视图逻辑</strong>
——远非我们实际想要的。尽管如此，这是一个很好的开始！让我们尝试逐步扩展它。</p>
<h3 id="初始化状态"><a class="header" href="#初始化状态">初始化状态</a></h3>
<p>我们的小运行时已经正确初始化了应用程序状态：</p>
<pre><code class="language-rust ignore">// 初始化状态
let mut counter = Counter { value: 0 };</code></pre>
<p>但是，我们可以通过利用 <code>Default</code> 特征来避免硬编码初始状态。让我们派生它：</p>
<pre><code class="language-rust">#[derive(Default)]
struct Counter {
    value: i64
}</code></pre>
<p>然后，我们在运行时中简单地使用 <code>Counter::default</code>：</p>
<pre><code class="language-rust ignore">// 初始化状态
let mut counter = Counter::default();</code></pre>
<p>差异可能很微妙，但我们正在分离关注点——我们将应用程序的初始状态保持在
状态定义附近，并与运行时分离。这样，我们最终可能能够让我们的运行时与
_任何_应用程序一起工作！</p>
<h3 id="显示界面"><a class="header" href="#显示界面">显示界面</a></h3>
<p>好的！我们已经初始化了<strong>状态</strong>。接下来是什么？嗯，在用户可以与我们的界面<strong>交互</strong>之前，我们
需要向他们<strong>显示</strong>它。</p>
<p>这很容易！我们只需要在用户运行的任何操作系统中打开一个窗口，初始化适当的图形后端，
然后渲染我们<strong>视图逻辑</strong>返回的组件——当然要正确布局！</p>
<p>什么？您不知道如何做到这一点？别担心，我有这个神奇的函数：<code>display</code>。它接受任何界面的引用并将其显示给用户。它完全有效！</p>
<pre><code class="language-rust ignore">use magic::display;

<span class="boring">// 初始化状态
</span><span class="boring">let mut counter = Counter::default();
</span><span class="boring">
</span>// 运行我们的视图逻辑以获得我们的界面
let interface = counter.view();

// 向用户显示界面
display(&amp;interface);</code></pre>
<p>看？简单！玩笑归玩笑，本章的目的不是让我们学习图形编程；而是让我们
更好地理解运行时是如何工作的。一点魔法不会有害！</p>
<h3 id="收集交互"><a class="header" href="#收集交互">收集交互</a></h3>
<p>用户正在看我们的界面并与之交互。我们需要非常注意所有
交互并产生我们的组件指定的所有相关<strong>消息</strong>。</p>
<p>如何？当然是用更多的魔法！我刚刚在我的礼帽里找到了这个 <code>interact</code> 函数——它接受一个
界面并产生对应于用户最新交互的<strong>消息</strong>。</p>
<pre><code class="language-rust ignore">use magic::{display, interact};

<span class="boring">// 初始化状态
</span><span class="boring">let mut counter = Counter::default();
</span><span class="boring">
</span><span class="boring">// 运行我们的视图逻辑以获得我们的界面
</span><span class="boring">let interface = counter.view();
</span><span class="boring">
</span><span class="boring">// 向用户显示界面
</span><span class="boring">display(&amp;interface);
</span><span class="boring">
</span>// 处理用户交互并获得我们的消息
let messages = interact(&amp;interface);</code></pre>
<p>太好了！<code>interact</code> 为我们返回一个<strong>消息</strong>列表——准备好被迭代。</p>
<h3 id="对交互做出反应"><a class="header" href="#对交互做出反应">对交互做出反应</a></h3>
<p>此时，我们已经收集了用户交互并将它们转换为一堆<strong>消息</strong>。为了
正确地对用户做出反应，我们需要为每个消息相应地更新我们的<strong>状态</strong>。</p>
<p>幸运的是，这一步不涉及更多的魔法技巧——我们可以只使用我们的<strong>更新逻辑</strong>：</p>
<pre><code class="language-rust ignore"><span class="boring">use magic::{display, interact};
</span><span class="boring">
</span><span class="boring">// 初始化状态
</span><span class="boring">let mut counter = Counter::default();
</span><span class="boring">
</span><span class="boring">// 运行我们的视图逻辑以获得我们的界面
</span><span class="boring">let interface = counter.view();
</span><span class="boring">
</span><span class="boring">// 向用户显示界面
</span><span class="boring">display(&amp;interface);
</span><span class="boring">
</span><span class="boring">// 处理用户交互并获得我们的消息
</span><span class="boring">let messages = interact(&amp;interface);
</span><span class="boring">
</span>// 通过处理每个消息来更新我们的状态
for message in messages {
    counter.update(message);
}</code></pre>
<p>这应该让我们的状态与最新的用户交互完全保持同步。</p>
<h3 id="循环"><a class="header" href="#循环">循环</a></h3>
<p>好的！我们的状态已经更新以反映用户交互。现在，我们需要再次向用户显示结果界面。之后，我们必须处理任何进一步的交互…然后，再次更新我们的状态。
然后…再次重复这一切！</p>
<p>这是一个循环！不，循环并不是很神奇——至少当我们编写 Rust 时不是：</p>
<pre><code class="language-rust ignore">use magic::{display, interact};

// 初始化状态
let mut counter = Counter::default();

// 保持交互。一直如此！
loop {
    // 运行我们的视图逻辑以获得我们的界面
    let interface = counter.view();

    // 向用户显示界面
    display(&amp;interface);

    // 处理用户交互并获得我们的消息
    let messages = interact(&amp;interface);

    // 通过处理每个消息来更新我们的状态
    for message in messages {
        counter.update(message);
    }
}</code></pre>
<p>恭喜！我们刚刚编写了一个完全功能的运行时——除了神奇的属性。我们可以清楚地理解这里
Elm 架构的每个基本部分如何适应应用程序的生命周期。</p>
<p>具体来说，</p>
<ul>
<li><strong>状态</strong>初始化一次，</li>
<li><strong>视图逻辑</strong>在启动时运行一次，然后在每批交互后运行，</li>
<li><strong>更新逻辑</strong>为每个创建<strong>消息</strong>的交互运行。</li>
</ul>
<h2 id="冰雪法师"><a class="header" href="#冰雪法师">冰雪法师</a></h2>
<p>“这很酷”，您说，“但我不是法师，我仍然不知道如何运行我编写的计数器界面。
我有东西要计算！”</p>
<p>很公平！iced 实现了一个与我们刚刚构建的非常相似的运行时。它自带
自己的魔法<sup class="footnote-reference" id="fr-magic-1"><a href="#footnote-magic">1</a></sup>——所以您不需要担心自己学习黑暗艺术。</p>
<p>如果我们想要运行我们的 <code>Counter</code>，我们所要做的就是调用 <a href="https://docs.iced.rs/iced/fn.run.html"><code>run</code></a>：</p>
<pre><code class="language-rust ignore iced(height=100px)"><span class="boring">use iced::widget::{button, column, text, Column};
</span><span class="boring">
</span>pub fn main() -&gt; iced::Result {
    iced::run("一个酷炫的计数器", Counter::update, Counter::view)
}
<span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">struct Counter {
</span><span class="boring">    value: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Clone, Copy)]
</span><span class="boring">enum Message {
</span><span class="boring">    Increment,
</span><span class="boring">    Decrement,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn update(&amp;mut self, message: Message) {
</span><span class="boring">        match message {
</span><span class="boring">            Message::Increment =&gt; {
</span><span class="boring">                self.value += 1;
</span><span class="boring">            }
</span><span class="boring">            Message::Decrement =&gt; {
</span><span class="boring">                self.value -= 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn view(&amp;self) -&gt; Column&lt;Message&gt; {
</span><span class="boring">        column![
</span><span class="boring">            button("+").on_press(Message::Increment),
</span><span class="boring">            text(self.value),
</span><span class="boring">            button("-").on_press(Message::Decrement),
</span><span class="boring">        ]
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<script>
function embed(script, hash, height) {
  var code = script.previousSibling;

  while(code && code.tagName != "PRE") {
    code = code.previousSibling;
  }

  let buttons = code.querySelector('.buttons');
  let play = document.createElement('button');

  async function run() {
    play.remove();

    let example = document.createElement('div');
    example.style.height = height;
    example.style.padding = "1rem";
    example.classList.add('hljs');

    let iced = document.createElement('div');
    iced.id = 'iced';
    iced.append(document.createTextNode('Loading...'));

    example.append(iced);
    code.append(example);

    let iceberg = await import(`/.icebergs/${hash}/iceberg.js`);
    await iceberg.default();
  }

  play.title = 'Run example';
  play.onclick = run;

  play.classList.add('fa');
  play.classList.add('fa-play');

  buttons.prepend(play);
}
</script>
<script type="module" id="iceberg-0">
  embed(document.getElementById("iceberg-0"), "199762893a5dd38e37491945836672c9a857a6c4c84635486a685f9ad9997", "100px");
</script>
<p>我们只是给我们的应用程序一个_酷炫_的标题，然后向
<strong>运行时</strong>提供<strong>更新逻辑</strong>和<strong>视图逻辑</strong>——然后它会处理其余的事情！</p>
<p>运行时能够从我们<strong>更新逻辑</strong>和<strong>视图逻辑</strong>的类型签名中推断出
<strong>状态</strong>和<strong>消息</strong>的类型。<strong>状态</strong>使用 <code>Default</code> 初始化，正如我们之前描述的。</p>
<p>还要注意 <a href="https://docs.iced.rs/iced/fn.run.html"><code>run</code></a> 可能失败，因此它返回一个 <a href="https://docs.iced.rs/iced/type.Result.html"><code>iced::Result</code></a>。如果我们所做的只是运行
应用程序，我们可以在 <code>main</code> 中直接返回这个结果。</p>
<p>就是这样！享受计算东西的乐趣吧——至少 3 亿年！</p>
<blockquote>
<h4 id="作者的话"><a class="header" href="#作者的话">作者的话</a></h4>
<p>您已经到达了本书的结尾，目前为止！</p>
<p>我认为它应该已经作为库基础知识的快速介绍。
还有很多东西需要揭示——但希望您现在已经到了可以开始
玩耍、享受乐趣和进一步实验的地步。</p>
<p>这本书远未完成——我想在这里涵盖更多主题，即：</p>
<ul>
<li>布局</li>
<li>样式</li>
<li>并发</li>
<li>扩展应用程序</li>
<li>扩展运行时</li>
<li>以及更多！</li>
</ul>
<p>在我写完它们之前，如果您想要探索和进一步学习，请查看<a href="additional-resources.html">其他资源</a>
章节。</p>
<p>我希望您到目前为止享受阅读。敬请期待！</p>
<p>— Héctor</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-magic">
<p>主要是 <a href="https://github.com/rust-windowing/winit"><code>winit</code></a>、<a href="https://github.com/rust-windowing/softbuffer"><code>softbuffer</code></a>、<a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a>、<a href="https://github.com/RazrFalcon/tiny-skia"><code>tiny-skia</code></a> 和 <a href="https://github.com/pop-os/cosmic-text"><code>cosmic-text</code></a>。 <a href="#fr-magic-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="其他资源"><a class="header" href="#其他资源">其他资源</a></h1>
<p>在我仍在编写这本书的时候，这里有一些您可以用来了解更多关于 iced 的进一步资源：</p>
<blockquote>
<p>请记住，这些资源中的一些可能使用的是较旧版本的 iced。然而，虽然使用的 API 的具体细节可能会改变，但 iced 的基本思想往往是相当稳定的。</p>
</blockquote>
<ul>
<li>一个<a href="https://www.youtube.com/watch?v=gcBJ7cPSALo">构建简单文本编辑器的逐步视频指南</a></li>
<li><a href="https://github.com/iced-rs/iced/tree/master/examples">官方示例</a></li>
<li><a href="https://docs.iced.rs/iced/">API 参考</a></li>
<li><a href="https://github.com/iced-rs/awesome-iced">官方精彩 iced 项目列表</a></li>
<li><a href="https://github.com/iced-rs/awesome-iced#Resources">非官方指南</a></li>
</ul>
<p>我们还有一个非常热情和活跃的社区！请随时在<a href="https://discord.gg/3xZJ65GAhd">我们的 Discord 服务器</a>或<a href="https://discourse.iced.rs/">我们的 Discourse 论坛</a>中提出任何问题。</p>
<p><a href="https://discord.gg/3xZJ65GAhd"><img src="https://img.shields.io/discord/628993209984614400?label=&amp;labelColor=6A7EC2&amp;logo=discord&amp;logoColor=ffffff&amp;color=7389D8" alt="Discord Server" /></a>
<a href="https://discourse.iced.rs/"><img src="https://img.shields.io/badge/dynamic/json?url=https%3A%2F%2Fdiscourse.iced.rs%2Fsite%2Fstatistics.json&amp;query=%24.users_count&amp;suffix=%20users&amp;label=discourse&amp;color=5e7ce2" alt="Discourse" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h1>
<h2 id="这本书什么时候完成"><a class="header" href="#这本书什么时候完成">这本书什么时候完成？</a></h2>
<p>Soon™。开源是一份礼物；所以随时我想写的时候。</p>
<h2 id="如何扩展大型应用程序"><a class="header" href="#如何扩展大型应用程序">如何扩展大型应用程序？</a></h2>
<p>您将应用程序拆分为多个屏幕，然后使用简单的组合。</p>
<p><a href="https://docs.rs/iced/0.13.1/iced/index.html#the-pocket-guide">袖珍指南</a> 有<a href="https://docs.rs/iced/0.13.1/iced/#scaling-applications">一个展示这种方法的特定部分</a>。</p>
<h2 id="我的应用程序如何从通道接收更新"><a class="header" href="#我的应用程序如何从通道接收更新">我的应用程序如何从通道接收更新？</a></h2>
<p>您可以使用 <a href="https://docs.rs/iced/0.13.1/iced/task/struct.Task.html#method.run"><code>Task::run</code></a> 从异步 <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a> 生成消息。</p>
<p>或者，如果您控制通道的创建；您可以使用 <a href="https://docs.rs/iced/0.13.1/iced/struct.Subscription.html#method.run"><code>Subscription::run</code></a>。</p>
<h2 id="iced-支持从右到左的文本和或-cjk-脚本吗"><a class="header" href="#iced-支持从右到左的文本和或-cjk-脚本吗">Iced 支持从右到左的文本和/或 CJK 脚本吗？</a></h2>
<p>还不是很好！</p>
<p>您可能能够使用带有 <a href="https://docs.rs/iced/0.13.1/iced/widget/text/enum.Shaping.html#variant.Advanced"><code>Shaping::Advanced</code></a> 的 <a href="https://docs.rs/iced/0.13.1/iced/widget/text/type.Text.html#method.shaping"><code>Text::shaping</code></a> 渲染一些脚本，
但这些脚本的文本编辑尚不受支持；<a href="https://en.wikipedia.org/wiki/Input_method">输入法编辑器</a> 也不受支持。</p>
<p>不过，这些功能在 <a href="https://whimsical.com/roadmap-iced-7vhq6R35Lp3TmYH4WeYwLM"><code>ROADMAP</code></a> 中！</p>
<h2 id="view-和-subscription-函数何时被调用"><a class="header" href="#view-和-subscription-函数何时被调用"><code>view</code> 和 <code>subscription</code> 函数何时被调用？</a></h2>
<p>在每批消息和 <code>update</code> 调用之后。但这是一个实现细节；
永远不应该依赖这一点。</p>
<p>尝试将这些函数视为声明性的、无状态的函数。</p>
<h2 id="iced-一直在重绘吗"><a class="header" href="#iced-一直在重绘吗">Iced 一直在重绘吗？！</a></h2>
<p>是的！iced 目前在每个运行时事件后重绘；包括微小的鼠标移动。</p>
<p>有计划通过检测组件状态变化来减少重绘频率，但性能到目前为止还不是优先考虑的。</p>
<p>渲染器确实执行了相当多的缓存；所以重绘相当便宜。因此，
对于大多数用例来说，这很少是问题！</p>
<h2 id="我收到一个恐慌说没有运行反应器这是怎么回事"><a class="header" href="#我收到一个恐慌说没有运行反应器这是怎么回事">我收到一个恐慌，说没有运行反应器。这是怎么回事？</a></h2>
<p>您可能正在使用 <code>Task</code> 来执行需要 <code>tokio</code> 执行器的 <code>Future</code>：</p>
<pre><code class="language-text">there is no reactor running, must be called from the context of a Tokio 1.x runtime
</code></pre>
<p>您应该能够通过在 <code>iced</code> crate 中启用 <a href="https://docs.rs/crate/iced/latest/features#tokio">the <code>tokio</code> feature flag</a> 来解决这个问题：</p>
<pre><code class="language-toml">iced = { version = "0.13", features = ["tokio"] }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
