<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Iced 中文教程 — Rust跨平台GUI库</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Iced 中文教程 — Rust跨平台GUI库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xiao-VoV/Iced_book_Chinese_pub" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div align="center">
  <img alt="The iced logo" src="resources/logo.svg" width="140">
</div>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://iced.rs">iced</a> is a cross-platform GUI library for <a href="https://rust-lang.org">Rust</a>. It is inspired by <a href="https://elm-lang.org">Elm</a>, a delightful functional language for building web applications.</p>
<p>As a GUI library, iced helps you build <em><a href="https://en.wikipedia.org/wiki/Graphical_user_interface">graphical user interfaces</a></em> for your Rust applications.</p>
<p>iced is strongly focused on <strong>simplicity</strong> and <strong>type-safety</strong>. As a result, iced tries to provide simple building blocks that can be put together with strong typing to reduce the chance of <strong>runtime errors</strong>.</p>
<p>This book will:</p>
<ul>
<li>Introduce you to the fundamental ideas of iced.</li>
<li>Teach you how to build interactive applications with iced.</li>
<li>Emphasize principles to scale and grow iced applications.</li>
</ul>
<p>Before proceeding, you should have some basic familiarity with Rust. If you are new to Rust or feel lost at some point, I recommend you to read <a href="https://doc.rust-lang.org/book/">the official Rust book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Let’s start from the basics! You are probably very familiar with graphical user interfaces already.
You can find them on your phone, computer, and most interactive electronic devices. In fact, you are
most likely reading this book using one!</p>
<p>At their essence, graphical user interfaces are applications that <strong>display</strong> some information graphically
to a user. This user can then choose to <strong>interact</strong> with the application—normally using some kind of device;
like a keyboard, mouse, or touchscreen.</p>
<div align="center">
  <img alt="Interface displays, user interacts" src="resources/gui-displays-user-interacts.svg">
</div>
<p>The user interactions may cause the application to update and display new information as a result, which in turn
may cause further user interactions, which in turn cause further updates… And so on. This quick feedback loop
is what causes the feeling of <em>interactivity</em>.</p>
<blockquote>
<p>Note: In this book, we will refer to graphical user interfaces as <strong>GUIs</strong>, <strong>UIs</strong>, <strong>user interfaces</strong>, or simply
<strong>interfaces</strong>. Technically, not all interfaces are graphical nor user-oriented; but, given the context of this
book, we will use all of these terms interchangeably.</p>
</blockquote>
<h2 id="dissecting-an-interface"><a class="header" href="#dissecting-an-interface">Dissecting an Interface</a></h2>
<p>Since we are interested in creating user interfaces, let’s take a closer look at them. We will start with a very
simple one: the classical counter interface. What is it made of?</p>
<div align="center">
  <img alt="A classical counter interface" src="resources/counter-interface.svg">
</div>
<p>As we can clearly see, this interface has three visibly distinct elements: two buttons with a number in between.
We refer to these visibly distinct elements of a user interface as <strong>widgets</strong> or <strong>elements</strong>.</p>
<p>Some <strong>widgets</strong> may be interactive, like a button. In the counter interface, the buttons can be used to trigger
certain <strong>interactions</strong>. Specifically, the button at the top can be used to increment the counter value, while the
button at the bottom can be used to decrement it.</p>
<p>We can also say that user interfaces are <em>stateful</em>—there is some <strong>state</strong> that persists between interactions.
The counter interface displays a number representing the counter value. The number displayed will change depending on
the amount of times we press the buttons. Pressing the increment button once will result in a different displayed value
compared to pressing it twice.</p>
<div align="center">
  <img alt="A dissected counter interface" src="resources/counter-interface-annotated.svg">
</div>
<h2 id="the-gui-trinity"><a class="header" href="#the-gui-trinity">The GUI Trinity</a></h2>
<p>Our quick dissection has successfully identified three foundational ideas in a user interface:</p>
<ul>
<li><strong>Widgets</strong> — the distinct visual elements of an interface.</li>
<li><strong>Interactions</strong> — the actions that may be triggered by some widgets.</li>
<li><strong>State</strong> — the underlying condition or information of an interface.</li>
</ul>
<p>These ideas are connected to each other, forming another feedback loop!</p>
<p><strong>Widgets</strong> produce <strong>interactions</strong> when a user interacts with them. These <strong>interactions</strong> then change the <strong>state</strong>
of the interface. The changed <strong>state</strong> propagates and dictates the new <strong>widgets</strong> that must be displayed. These new
<strong>widgets</strong> may then produce new <strong>interactions</strong>, which can change the <strong>state</strong> again… And so on.</p>
<div align="center">
  <img alt="The GUI trinity" src="resources/the-gui-trinity.svg">
</div>
<p>These ideas and their connections make up the fundamental architecture of a user interface. Therefore, creating a user
interface must inevitably consist in defining these <strong>widgets</strong>, <strong>interactions</strong>, and <strong>state</strong>; as well as the connections
between them.</p>
<h2 id="different-ideas-different-nature"><a class="header" href="#different-ideas-different-nature">Different Ideas, Different Nature</a></h2>
<p>The three foundational ideas of an interface differ quite a bit when it comes to reusability.</p>
<p>The state and the interactions of an interface are very specific to the application and its purpose. If I tell you that
I have an interface with a numeric value and increment and decrement interactions, you will very easily
guess I am talking about a counter interface.</p>
<p>However, if I tell you I have an interface with two buttons and a number… It’s quite trickier for you to guess the kind
of interface I am talking about. It could be anything!</p>
<p>This is because widgets are generally very generic and, therefore, more reusable. Most interfaces display a combination of
familiar widgets—like buttons and numbers. In fact, users expect familiar widgets to always behave a certain way. If they
don’t behave properly, the interface will be unintuitive and have poor <a href="https://en.wikipedia.org/wiki/User_experience">user experience</a>.</p>
<p>While widgets are generally very reusable; the specific widget configuration dictated by the application state and its
interactions is very application-specific. A button is generic; but a button that has a “+” label and causes a value
increment when pressed is very specific.</p>
<p>All of this means that, when we are creating a specific user interface, we don’t want to focus on implementing every
familiar widget and its behavior. Instead, we want to leverage widgets as reusable building blocks—independent of our
application and provided by some library—while placing our focus on the application-specific parts of the fundamental
architecture: state, interactions, how the interactions change the state, and how the state dictates the widgets.</p>
<div align="center">
  <img alt="The application-specific parts of a GUI" src="resources/the-gui-trinity-focused.svg">
</div>
<h2 id="the-elm-architecture"><a class="header" href="#the-elm-architecture">The Elm Architecture</a></h2>
<p>It turns out that the four application-specific parts of the architecture of an interface are also the four foundational
ideas of <a href="https://guide.elm-lang.org/architecture/">The Elm Architecture</a>.</p>
<blockquote>
<p>The Elm Architecture is a pattern for architecting interactive programs that emerges naturally in <a href="https://elm-lang.org/">Elm</a>, a delightful
purely functional programming language for reliable web applications.</p>
<p>Patterns and ideas that emerge in purely functional programming languages tend to work very well in Rust
because they leverage immutability and <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>—both very desirable properties that not only
make code easy to reason about, but also play nicely with the borrow checker.</p>
<p>Furthermore, The Elm Architecture not only emerges naturally in Elm, but also when simply dissecting user
interfaces and formalizing their inner workings; like we just did in this chapter.</p>
</blockquote>
<p>The Elm Architecture uses a different—if not more precise—nomenclature for its fundamental parts:</p>
<ul>
<li><strong>Model</strong> — the state of the application.</li>
<li><strong>Messages</strong> — the interactions of the application.</li>
<li><strong>Update logic</strong> — how the messages change the state.</li>
<li><strong>View logic</strong> — how the state dictates the widgets.</li>
</ul>
<p>These are different names, but they point to the same exact fundamental ideas we have already discovered and,
therefore, can be used interchangeably.</p>
<div align="center">
  <img alt="The Elm Architecture" src="resources/the-elm-architecture.svg">
</div>
<blockquote>
<p>Note: In iced, the names <strong>state</strong> and <strong>messages</strong> are used more often than <strong>model</strong> and
<strong>interactions</strong>, respectively.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-steps"><a class="header" href="#first-steps">First Steps</a></h1>
<p>But enough with the theory. It’s about time we start writing some code!</p>
<p>iced embraces The Elm Architecture as the most natural approach for architecting interactive applications.
Therefore, when using iced, we will be dealing with the four main ideas we introduced in the previous chapter:
<strong>state</strong>, <strong>messages</strong>, <strong>update logic</strong>, and <strong>view logic</strong>.</p>
<p>In the previous chapter, we dissected and studied the classical counter interface. Let’s try to
build it in Rust while leveraging The Elm Architecture.</p>
<div align="center">
  <img alt="A classical counter interface" src="resources/counter-interface-annotated.svg">
</div>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>Let’s start with the <strong>state</strong>—the underlying data of the application.</p>
<p>In Rust, given the ownership and borrowing rules, it is extremely important to think carefully about the data model
of your application.</p>
<blockquote>
<p>I encourage you to always start by pondering about the data of your application and
its different states—not only those that are possible, but also those that must be impossible. Then try to leverage
the type system as much as you can to <em><a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Make Impossible States Impossible</a></em>.</p>
</blockquote>
<p>For our counter interface, all we need is a counter value. Since we have both increment and decrement interactions,
the number could potentially be negative. This means we need a signed integer.</p>
<p>Also, we know some users are crazy and they may want to count a lot of things. Let’s give them 64 bits to play with:</p>
<pre><code class="language-rust">struct Counter {
    value: i64,
}</code></pre>
<p>If a crazy user counted 1000 things every second, it would take them ~300 million years to run out of numbers.
Let’s hope that’s enough.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>Next, we need to define our <strong>messages</strong>—the interactions of the application.</p>
<p>Our counter interface has two interactions: <strong>increment</strong> and <strong>decrement</strong>. Technically, we could use a simple boolean to
encode these interactions: <code>true</code> for increment and <code>false</code> for decrement, for instance.</p>
<p>But… we can do better in Rust! Interactions are mutually exclusive—when we have an interaction, what we really have is one
value of a possible set of values. It turns out that Rust has the perfect data type for modeling this kind of idea: the <em>enum</em>.</p>
<p>Thus, we can define our messages like this:</p>
<pre><code class="language-rust">enum Message {
    Increment,
    Decrement,
}</code></pre>
<p>Simple enough! This also sets us up for the long-term. If we ever wanted to add additional interactions to our application—like a
<code>Reset</code> interaction, for instance—we could just introduce additional variants to this type. Enums are very powerful and convenient.</p>
<h2 id="update-logic"><a class="header" href="#update-logic">Update Logic</a></h2>
<p>Now, it’s time for our <strong>update logic</strong>—how messages change the state of the application.</p>
<p>Basically, we need to write some logic that given any message can update any state of the application accordingly. The simplest
and most idiomatic way to express this logic in Rust is by defining a method named <code>update</code> in our application state.</p>
<p>For our counter interface, we only need to properly increment or decrement the <code>value</code> of our <code>Counter</code> struct based on the <code>Message</code>
we just defined:</p>
<pre><code class="language-rust ignore">impl Counter {
    fn update(&amp;mut self, message: Message) {
        match message {
            Message::Increment =&gt; {
                self.value += 1;
            }
            Message::Decrement =&gt; {
                self.value -= 1;
            }
        }
    }
}</code></pre>
<p>Great! Now we are ready to process user interactions. For instance, imagine we initialized our counter like this:</p>
<pre><code class="language-rust ignore">let mut counter = Counter { value: 0 };</code></pre>
<p>And let’s say we wanted to simulate a user playing with our interface for a bit—pressing the increment button twice
and then the decrement button once. We could easily compute the final state of our counter with our <strong>update logic</strong>:</p>
<pre><code class="language-rust ignore">counter.update(Message::Increment);
counter.update(Message::Increment);
counter.update(Message::Decrement);</code></pre>
<p>This would cause our <code>Counter</code> to end up with a <code>value</code> of <code>1</code>:</p>
<pre><code class="language-rust ignore">assert_eq!(counter.value, 1);</code></pre>
<p>In fact, we have just written a simple test for our application logic:</p>
<pre><code class="language-rust ignore">#[test]
fn it_counts_properly() {
    let mut counter = Counter { value: 0 };

    counter.update(Message::Increment);
    counter.update(Message::Increment);
    counter.update(Message::Decrement);

    assert_eq!(counter.value, 1);
}</code></pre>
<p>Notice how easy this was to write! So far, we are just leveraging very simple Rust concepts. No dependencies in sight!
You may even be wondering… “Where is the GUI code?!”</p>
<p>This is one of the main advantages of The Elm Architecture. As we discovered in the previous chapter, widgets are the
only fundamental idea of an interface that is reusable in nature. All the parts we have defined so far are application-specific
and, therefore, do not need to know about the UI library at all!</p>
<p>The Elm Architecture properly embraces the different nature of each part of a user interface—decoupling <strong>state</strong>,
<strong>messages</strong>, and <strong>update logic</strong> from <strong>widgets</strong> and <strong>view logic</strong>.</p>
<h2 id="view-logic"><a class="header" href="#view-logic">View Logic</a></h2>
<p>Finally, the only part left for us to define is our <strong>view logic</strong>—how state dictates the widgets of the application.</p>
<p>Here is where the magic happens! In view logic, we bring together the state of the application and its possible interactions
to produce a visual representation of the user interface that must be displayed to the user.</p>
<div align="center" class="right">
  <img alt="A classical counter interface" src="resources/counter-interface.svg" width="50%">
</div>
<p>As we have already learned, this visual representation is made of widgets—the visibly distinct units of an interface. Most
widgets are not application-specific and they can be abstracted and packaged into reusable libraries. These libraries are
normally called <em>widget toolkits</em>, <em>GUI frameworks</em>, or simply <em>GUI libraries</em>.</p>
<p>And this is where <strong>iced</strong> comes in—finally! iced is a cross-platform GUI library for Rust. It packages a fair collection of
ready-to-use widgets; buttons and numbers included. Exactly what we need for our counter.</p>
<h3 id="the-buttons"><a class="header" href="#the-buttons">The Buttons</a></h3>
<p>Our counter interface has two <strong>buttons</strong>. Let’s see how we can define them using iced.</p>
<p>In iced, widgets are independent values. The same way you can have an integer in a variable, you can have a widget as well.
These values are normally created using a <em>helper function</em> from the <code>widget</code> module.</p>
<p>For our buttons, we can use the <code>button</code> helper:</p>
<pre><code class="language-rust ignore">use iced::widget::button;

let increment = button("+");
let decrement = button("-");</code></pre>
<p>That’s quite simple, isn’t it? For now, we have just defined a couple of variables for our buttons.</p>
<p>As we can see, widget helpers may take arguments for configuring parts of the widgets to our liking.
In this case, the <code>button</code> function takes a single argument used to describe the contents of the button.</p>
<h3 id="the-number"><a class="header" href="#the-number">The Number</a></h3>
<p>We have our buttons sitting nicely in our <code>increment</code> and <code>decrement</code> variables. How about we do the same
for our counter value?</p>
<p>While iced does not really have a <code>number</code> widget, it does have a more generic <code>text</code> widget that can be used
to display any kind of text—numbers included:</p>
<pre><code class="language-rust ignore">use iced::widget::text;

let counter = text(15);</code></pre>
<p>Sweet! Like <code>button</code>, <code>text</code> also takes an argument used to describe its contents. Since we are just getting started, let’s
simply hardcode <code>15</code> for now.</p>
<h3 id="the-layout"><a class="header" href="#the-layout">The Layout</a></h3>
<p>Alright! We have our two buttons in <code>increment</code> and <code>decrement</code>, and our counter value in <code>counter</code>. That should be everything, right?</p>
<p>Not so fast! The widgets in our counter interface are displayed in a specific <strong>order</strong>. Given our three widgets, there is a total of
<strong>six</strong> different ways to order them. However, the order we want is: <code>increment</code>, <code>counter</code>, and <code>decrement</code>.</p>
<p>A very simple way of describing this order is to create a list with our widgets:</p>
<pre><code class="language-rust ignore">let interface = vec![increment, counter, decrement];</code></pre>
<p>But we are still missing something! It’s not only the order that is specific, our interface also has a specific visual <strong>layout</strong>.</p>
<p>The widgets are positioned on top of each other, but they could very well be positioned from left to right instead. There is nothing
in our description so far that talks about the <strong>layout</strong> of our widgets.</p>
<p>In iced, layout is described using… well, more widgets! That’s right. Not all widgets produce visual results directly; some may simply
manage the position of existing widgets. And since widgets are just values, they can be nested and composed nicely.</p>
<p>The kind of vertical layout that we need for our counter can be achieved with the <code>column</code> widget:</p>
<pre><code class="language-rust ignore">use iced::widget::column;

let interface = column![increment, counter, decrement];</code></pre>
<p>This is very similar to our previous snippet. iced provides a <code>column!</code> macro for creating a <code>column</code> out of some widgets in a particular
<strong>order</strong>—analogous to <code>vec!</code>.</p>
<h3 id="the-interactions"><a class="header" href="#the-interactions">The Interactions</a></h3>
<p>At this point, we have in our <code>interface</code> variable a <code>column</code> representing our counter interface. But if we actually tried to run it,
we would quickly find out that something is wrong.</p>
<p>Our buttons would be completely disabled. Of course! We have not defined any <strong>interactions</strong> for them. Notice that we have yet
to use our <code>Message</code> enum in our view logic. How is our user interface supposed to produce <strong>messages</strong> if we don’t specify
them? Let’s do that now.</p>
<p>In iced, every widget has a specific type that enables further configuration using simple builder methods. The <code>button</code>
helper returns an instance of <a href="https://docs.rs/iced/0.12.1/iced/widget/struct.Button.html">the <code>Button</code> type</a>, which has an <code>on_press</code> method we can use to define the message it must
<strong>produce</strong> when a user presses the button:</p>
<pre><code class="language-rust ignore">use iced::widget::button;

let increment = button("+").on_press(Message::Increment);
let decrement = button("-").on_press(Message::Decrement);</code></pre>
<p>Awesome! Our interactions are wired up. But there is still a small detail left. A button can be pressed multiple times. Therefore,
the same button may need to produce multiple instances of the same <code>Message</code>. As a result, we need our <code>Message</code> type to be cloneable.</p>
<p>We can easily <em>derive</em> the <code>Clone</code> trait—as well as <code>Debug</code> and <code>Copy</code> for good measure:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy)]
enum Message {
    Increment,
    Decrement,
}</code></pre>
<p>In The Elm Architecture, messages represent <strong>events</strong> that have occurred—made of pure data. As a consequence, it should always be easy
to derive <code>Debug</code> and <code>Clone</code> for our <code>Message</code> type.</p>
<h3 id="the-view"><a class="header" href="#the-view">The View</a></h3>
<p>We are almost there! There is only one thing left to do: connecting our application <strong>state</strong> to the view logic.</p>
<p>Let’s bring together all the view logic we have written so far:</p>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text};

// The buttons
let increment = button("+").on_press(Message::Increment);
let decrement = button("-").on_press(Message::Decrement);

// The number
let counter = text(15);

// The layout
let interface = column![increment, counter, decrement];</code></pre>
<p>If we ran this view logic, we would now be able to press the buttons. However, nothing would happen as a result. The
counter would be stuck—always showing the number <code>15</code>. Our interface is completely stateless!</p>
<p>Obviously, the issue here is that our <code>counter</code> variable contains a text widget with a hardcoded <code>15</code>. Instead, what
we want is to actually display the <code>value</code> field of our <code>Counter</code> state. This way, when a button is pressed and
our update logic is triggered, the text widget will display the new <code>value</code>.</p>
<p>We can easily do this by running our view logic in a method of our <code>Counter</code>—just like we did with our update logic:</p>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text};

impl Counter {
    fn view(&amp;self) {
        // The buttons
        let increment = button("+").on_press(Message::Increment);
        let decrement = button("-").on_press(Message::Decrement);

        // The number
        let counter = text(self.value);

        // The layout
        let interface = column![increment, counter, decrement];
    }
}</code></pre>
<p>Our <code>counter</code> variable now will always have a <code>text</code> widget with the current <code>value</code> of our <code>Counter</code>. Great!</p>
<p>However, and as you may have noticed, this <code>view</code> method is completely useless—it constructs an
<code>interface</code>, but then… It does nothing with it and throws it away!</p>
<blockquote>
<p>In iced, constructing and configuring widgets has no side effects. There is no “global context” you need to
worry about in your view code.</p>
</blockquote>
<p>Instead of throwing the <code>interface</code> away, we need to return it. Remember, the purpose of our <strong>view logic</strong> is
to dictate the widgets of our user interface; and the content of the <code>interface</code> variable is precisely the
description of the interface we want:</p>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text, Column};

impl Counter {
    fn view(&amp;self) -&gt; Column&lt;Message&gt; {
        // The buttons
        let increment = button("+").on_press(Message::Increment);
        let decrement = button("-").on_press(Message::Decrement);

        // The number
        let counter = text(self.value);

        // The layout
        let interface = column![increment, counter, decrement];

        interface
    }
}</code></pre>
<p>Tada! Notice how the <code>view</code> method needs a return type now. The returned type is <code>Column</code> because the <code>column!</code> macro produces
a widget of this type—just like <code>button</code> produces a widget of the <code>Button</code> type.</p>
<p>You may also have noticed that this <code>Column</code> type has a generic type parameter. This type parameter simply specifies the type
of messages the widget may produce. In this case, it takes our <code>Message</code> because the <code>increment</code> and <code>decrement</code> buttons inside
the column produce messages of this type.</p>
<blockquote>
<p>iced has a strong focus on type safety—leveraging the type system and compile-time guarantees to minimize runtime errors
as much as possible.</p>
</blockquote>
<p>And well… That’s it! Our view logic is done! But wait… It’s a bit verbose right now. Since it’s such a simple interface,
let’s just inline everything:</p>
<div align="center" class="right">
  <img alt="A classical counter interface" src="resources/counter-interface.svg" width="50%">
</div>
<pre><code class="language-rust ignore">use iced::widget::{button, column, text, Column};

impl Counter {
    fn view(&amp;self) -&gt; Column&lt;Message&gt; {
        column![
            button("+").on_press(Message::Increment),
            text(self.value),
            button("-").on_press(Message::Decrement),
        ]
    }
}</code></pre>
<p>That’s much more concise. It even resembles the actual interface! Since creating widgets just yields values with no
side effects; we can move things around in our view logic without worrying about breaking other stuff. No spooky
action at a distance!</p>
<p>And that’s all there is to our counter interface. I am sure you can’t wait to <strong>run</strong> it. Shall we?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-runtime"><a class="header" href="#the-runtime">The Runtime</a></h1>
<p>In the previous chapter we built the classical counter interface using iced and The Elm Architecture. We focused on each
fundamental part—one at a time: <strong>state</strong>, <strong>messages</strong>, <strong>update logic</strong>, and <strong>view logic</strong>.</p>
<p>But now what? Yes, we have all the fundamental parts of a user interface—as we learned during
<a href="architecture.html">our dissection</a>—but it is unclear how we are supposed to bring it to life.</p>
<p>It seems we are missing <em>something</em> that can put all the parts together and <em>run</em> them in unison. <em>Something</em> that
creates and runs the fundamental loop of a user interface—displaying widgets to a user and reacting to any interactions.</p>
<p>This <em>something</em> is called the <strong>runtime</strong>. You can think of it as the environment where the feedback loop of a user
interface takes place. The runtime is in charge of every part of the loop: initializing the <strong>state</strong>,
producing <strong>messages</strong>, executing the <strong>update logic</strong>, and running our <strong>view logic</strong>.</p>
<div align="center">
  <img alt="The Runtime" src="resources/the-runtime.svg">
</div>
<blockquote>
<p>Another way to picture the runtime is by imagining a huge engine with four fundamental parts missing. Our job is
to fill in these parts—and then the engine can run!</p>
</blockquote>
<h2 id="a-magical-runtime"><a class="header" href="#a-magical-runtime">A Magical Runtime</a></h2>
<p>Let’s try to get a better understanding of the lifetime of an interface by exploring the internals of a basic (although very magical!) runtime.</p>
<p>In fact, we have actually started writing a runtime already! When <a href="first-steps.html#update-logic">we implemented the update logic of our counter</a>,
we wrote a very small test that simulated a user:</p>
<pre><code class="language-rust ignore">#[test]
fn it_counts_properly() {
    let mut counter = Counter { value: 0 };

    counter.update(Message::Increment);
    counter.update(Message::Increment);
    counter.update(Message::Decrement);

    assert_eq!(counter.value, 1);
}</code></pre>
<p>This is technically a very bare-bones runtime. It initializes the <strong>state</strong>, produces some <strong>interactions</strong>,
and executes the <strong>update logic</strong>.</p>
<p>Of course, the interactions are made up, it is very short-lived, and there is no <strong>view logic</strong>
involved—far from what we actually want. Still, it’s a great start! Let’s try to extend it, step by step.</p>
<h3 id="initializing-the-state"><a class="header" href="#initializing-the-state">Initializing the State</a></h3>
<p>Our small runtime is already initializing the application state properly:</p>
<pre><code class="language-rust ignore">// Initialize the state
let mut counter = Counter { value: 0 };</code></pre>
<p>However, we can avoid hardcoding the initial state by leveraging the <code>Default</code> trait. Let’s just derive it:</p>
<pre><code class="language-rust">#[derive(Default)]
struct Counter {
    value: i64
}</code></pre>
<p>And then, we simply use <code>Counter::default</code> in our runtime:</p>
<pre><code class="language-rust ignore">// Initialize the state
let mut counter = Counter::default();</code></pre>
<p>The difference may be subtle, but we are separating concerns—we keep the initial state of our application close to
the state definition and separated from the runtime. This way, we may eventually be able to make our runtime work with
<em>any</em> application!</p>
<h3 id="displaying-the-interface"><a class="header" href="#displaying-the-interface">Displaying the Interface</a></h3>
<p>Alright! We have our <strong>state</strong> initialized. What’s next? Well, before a user can <strong>interact</strong> with our interface, we
need to <strong>display</strong> it to them.</p>
<p>That’s easy! We just need to open a window in whatever OS the user is running, initialize a proper graphics backend,
and then render the widgets returned by our <strong>view logic</strong>—properly laid out, of course!</p>
<p>What? You have no clue of how to do that? Don’t worry, I have this magical function: <code>display</code>. It takes a reference to
any interface and displays it to the user. It totally works!</p>
<pre><code class="language-rust ignore">use magic::display;

<span class="boring">// Initialize the state
</span><span class="boring">let mut counter = Counter::default();
</span><span class="boring">
</span>// Run our view logic to obtain our interface
let interface = counter.view();

// Display the interface to the user
display(&amp;interface);</code></pre>
<p>See? Easy! Jokes aside, the purpose of this chapter is not for us to learn graphics programming; but for us
to get a better understanding of how a runtime works. A little bit of magic doesn’t hurt!</p>
<h3 id="gathering-the-interactions"><a class="header" href="#gathering-the-interactions">Gathering the Interactions</a></h3>
<p>The user is seeing our interface and is now interacting with it. We need to pay very good attention to all
the interactions and produce all the relevant <strong>messages</strong> that our widgets specify.</p>
<p>How? With some more magic, of course! I just found this <code>interact</code> function inside of my top hat—it takes an
interface and produces the <strong>messages</strong> that correspond to the latest interactions of the user.</p>
<pre><code class="language-rust ignore">use magic::{display, interact};

<span class="boring">// Initialize the state
</span><span class="boring">let mut counter = Counter::default();
</span><span class="boring">
</span><span class="boring">// Run our view logic to obtain our interface
</span><span class="boring">let interface = counter.view();
</span><span class="boring">
</span><span class="boring">// Display the interface to the user
</span><span class="boring">display(&amp;interface);
</span><span class="boring">
</span>// Process the user interactions and obtain our messages
let messages = interact(&amp;interface);</code></pre>
<p>Great! <code>interact</code> returns a list of <strong>messages</strong> for us—ready to be iterated.</p>
<h3 id="reacting-to-the-interactions"><a class="header" href="#reacting-to-the-interactions">Reacting to the Interactions</a></h3>
<p>At this point, we have gathered the user interactions and we have turned them into a bunch of <strong>messages</strong>. In order to
react properly to the user, we need to update our <strong>state</strong> accordingly for each message.</p>
<p>Luckily, there are no more magic tricks involved in this step—we can just use our <strong>update logic</strong>:</p>
<pre><code class="language-rust ignore"><span class="boring">use magic::{display, interact};
</span><span class="boring">
</span><span class="boring">// Initialize the state
</span><span class="boring">let mut counter = Counter::default();
</span><span class="boring">
</span><span class="boring">// Run our view logic to obtain our interface
</span><span class="boring">let interface = counter.view();
</span><span class="boring">
</span><span class="boring">// Display the interface to the user
</span><span class="boring">display(&amp;interface);
</span><span class="boring">
</span><span class="boring">// Process the user interactions and obtain our messages
</span><span class="boring">let messages = interact(&amp;interface);
</span><span class="boring">
</span>// Update our state by processing each message
for message in messages {
    counter.update(message);
}</code></pre>
<p>That should keep our state completely up-to-date with the latest user interactions.</p>
<h3 id="looping-around"><a class="header" href="#looping-around">Looping Around</a></h3>
<p>Okay! Our state has been updated to reflect the user interactions. Now, we need to display the resulting interface again
to the user. And after that, we must process any further interactions… And then, update our state once more.
And then… Do it all over once again!</p>
<p>This is a loop! And no, loops aren’t very magical—not when we write Rust, at least:</p>
<pre><code class="language-rust ignore">use magic::{display, interact};

// Initialize the state
let mut counter = Counter::default();

// Be interactive. All the time! 
loop {
    // Run our view logic to obtain our interface
    let interface = counter.view();

    // Display the interface to the user
    display(&amp;interface);

    // Process the user interactions and obtain our messages
    let messages = interact(&amp;interface);

    // Update our state by processing each message
    for message in messages {
        counter.update(message);
    }
}</code></pre>
<p>Congratulations! We just wrote a perfectly functional runtime—magical properties aside. We can clearly understand here how
each fundamental part of The Elm Architecture fits in the lifetime of an application.</p>
<p>Specifically,</p>
<ul>
<li><strong>state</strong> is initialized once,</li>
<li><strong>view logic</strong> runs once at startup and then after every batch of interactions,</li>
<li>and <strong>update logic</strong> runs for every interaction that created a <strong>message</strong>.</li>
</ul>
<h2 id="the-ice-wizard"><a class="header" href="#the-ice-wizard">The Ice Wizard</a></h2>
<p>“That’s cool and all”, you say, “but I am not a wizard and I still have no clue of how to run the counter interface I wrote.
I have things to count!”</p>
<p>Fair enough! iced implements a very similar runtime to the one we just built. It comes bundled with
its own magic<sup class="footnote-reference" id="fr-magic-1"><a href="#footnote-magic">1</a></sup>—so you don’t need to worry about learning the dark arts yourself.</p>
<p>If we want to run our <code>Counter</code>, all we have to do is call <a href="https://docs.iced.rs/iced/fn.run.html"><code>run</code></a>:</p>
<pre><code class="language-rust ignore iced(height=100px)"><span class="boring">use iced::widget::{button, column, text, Column};
</span><span class="boring">
</span>pub fn main() -&gt; iced::Result {
    iced::run("A cool counter", Counter::update, Counter::view)
}
<span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">struct Counter {
</span><span class="boring">    value: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Clone, Copy)]
</span><span class="boring">enum Message {
</span><span class="boring">    Increment,
</span><span class="boring">    Decrement,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn update(&amp;mut self, message: Message) {
</span><span class="boring">        match message {
</span><span class="boring">            Message::Increment =&gt; {
</span><span class="boring">                self.value += 1;
</span><span class="boring">            }
</span><span class="boring">            Message::Decrement =&gt; {
</span><span class="boring">                self.value -= 1;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn view(&amp;self) -&gt; Column&lt;Message&gt; {
</span><span class="boring">        column![
</span><span class="boring">            button("+").on_press(Message::Increment),
</span><span class="boring">            text(self.value),
</span><span class="boring">            button("-").on_press(Message::Decrement),
</span><span class="boring">        ]
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<script>
function embed(script, hash, height) {
  var code = script.previousSibling;

  while(code && code.tagName != "PRE") {
    code = code.previousSibling;
  }

  let buttons = code.querySelector('.buttons');
  let play = document.createElement('button');

  async function run() {
    play.remove();

    let example = document.createElement('div');
    example.style.height = height;
    example.style.padding = "1rem";
    example.classList.add('hljs');

    let iced = document.createElement('div');
    iced.id = 'iced';
    iced.append(document.createTextNode('Loading...'));

    example.append(iced);
    code.append(example);

    let iceberg = await import(`/.icebergs/${hash}/iceberg.js`);
    await iceberg.default();
  }

  play.title = 'Run example';
  play.onclick = run;

  play.classList.add('fa');
  play.classList.add('fa-play');

  buttons.prepend(play);
}
</script>
<script type="module" id="iceberg-0">
  embed(document.getElementById("iceberg-0"), "55288b479ffed7c5afc0902c91faa1812555df2c747f4c091f1e2dca985faa", "100px");
</script>
<p>We just give our application a <em>cool</em> title and then provide the <strong>update logic</strong> and <strong>view logic</strong> to
the <strong>runtime</strong>—which then figures out the rest!</p>
<p>The runtime is capable of inferring the types for the <strong>state</strong> and <strong>messages</strong> out of the type signatures of
our <strong>update logic</strong> and <strong>view logic</strong>. The <strong>state</strong> is initialized leveraging <code>Default</code>, as we described earlier.</p>
<p>Notice also that <a href="https://docs.iced.rs/iced/fn.run.html"><code>run</code></a> can fail and, therefore, it returns an <a href="https://docs.iced.rs/iced/type.Result.html"><code>iced::Result</code></a>. If all we are doing is run the
application, we can return this result directly in <code>main</code>.</p>
<p>And that should be it! Have fun counting things for 300 million years—at least!</p>
<blockquote>
<h4 id="note-from-the-author"><a class="header" href="#note-from-the-author">Note From the Author</a></h4>
<p>You reached the end of the book, for now!</p>
<p>I think it should already serve as a quick introduction to the basics of the library.
There is a lot more to unravel—but hopefully you are now at a point where you can start
playing around, having fun, and experimenting further.</p>
<p>The book is far from finished—there are a lot more topics I want to cover here, namely:</p>
<ul>
<li>Layout</li>
<li>Styling</li>
<li>Concurrency</li>
<li>Scaling Applications</li>
<li>Extending the Runtime</li>
<li>And More!</li>
</ul>
<p>Until I get to write them, check out the <a href="additional-resources.html">Additional Resources</a>
chapter if you want to explore and learn further.</p>
<p>I hope that you enjoyed the read so far. Stay tuned!</p>
<p>— Héctor</p>
</blockquote>
<hr>
<ol class="footnote-definition"><li id="footnote-magic">
<p>Mainly <a href="https://github.com/rust-windowing/winit"><code>winit</code></a>, <a href="https://github.com/rust-windowing/softbuffer"><code>softbuffer</code></a>, <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a>, <a href="https://github.com/RazrFalcon/tiny-skia"><code>tiny-skia</code></a>, and <a href="https://github.com/pop-os/cosmic-text"><code>cosmic-text</code></a>. <a href="#fr-magic-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h1>
<p>Here are some further resources you can use to learn more about iced while I am still working on this book:</p>
<blockquote>
<p>Keep in mind that some of these resources may be using an older version of iced. However, while the specifics
of the APIs used may change, the fundamental ideas of iced tend to be quite stable.</p>
</blockquote>
<ul>
<li>A <a href="https://www.youtube.com/watch?v=gcBJ7cPSALo">step-by-step video guide to building a simple text editor</a></li>
<li>The <a href="https://github.com/iced-rs/iced/tree/master/examples">official examples</a></li>
<li>The <a href="https://docs.iced.rs/iced/">API Reference</a></li>
<li>The <a href="https://github.com/iced-rs/awesome-iced">official list of awesome iced projects</a></li>
<li>The <a href="https://github.com/iced-rs/awesome-iced#Resources">unofficial guides</a></li>
</ul>
<p>We also have a very welcoming and active community! Feel free to ask any questions in <a href="https://discord.gg/3xZJ65GAhd">our Discord server</a> or <a href="https://discourse.iced.rs/">our Discourse forum</a>.</p>
<p><a href="https://discord.gg/3xZJ65GAhd"><img src="https://img.shields.io/discord/628993209984614400?label=&amp;labelColor=6A7EC2&amp;logo=discord&amp;logoColor=ffffff&amp;color=7389D8" alt="Discord Server" /></a>
<a href="https://discourse.iced.rs/"><img src="https://img.shields.io/badge/dynamic/json?url=https%3A%2F%2Fdiscourse.iced.rs%2Fsite%2Fstatistics.json&amp;query=%24.users_count&amp;suffix=%20users&amp;label=discourse&amp;color=5e7ce2" alt="Discourse" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h2 id="when-will-the-book-be-finished"><a class="header" href="#when-will-the-book-be-finished">When Will the Book Be Finished?</a></h2>
<p>Soon™. Open source is a gift; so whenever I feel like it.</p>
<h2 id="how-do-i-scale-a-large-application"><a class="header" href="#how-do-i-scale-a-large-application">How Do I Scale a Large Application?</a></h2>
<p>You split your application into multiple screens, and then use simple composition.</p>
<p><a href="https://docs.rs/iced/0.13.1/iced/index.html#the-pocket-guide">The Pocket Guide</a> has <a href="https://docs.rs/iced/0.13.1/iced/#scaling-applications">a specific section that showcases this approach</a>.</p>
<h2 id="how-can-my-application-receive-updates-from-a-channel"><a class="header" href="#how-can-my-application-receive-updates-from-a-channel">How Can My Application Receive Updates From a Channel?</a></h2>
<p>You can use <a href="https://docs.rs/iced/0.13.1/iced/task/struct.Task.html#method.run"><code>Task::run</code></a> to generate messages from an asynchronous <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>Stream</code></a>.</p>
<p>Alternatively, if you control the creation of the channel; you can use <a href="https://docs.rs/iced/0.13.1/iced/struct.Subscription.html#method.run"><code>Subscription::run</code></a>.</p>
<h2 id="does-iced-support-right-to-left-text-andor-cjk-scripts"><a class="header" href="#does-iced-support-right-to-left-text-andor-cjk-scripts">Does Iced Support Right-To-Left Text and/or CJK scripts?</a></h2>
<p>Not very well yet!</p>
<p>You may be able to render some scripts using <a href="https://docs.rs/iced/0.13.1/iced/widget/text/type.Text.html#method.shaping"><code>Text::shaping</code></a> with <a href="https://docs.rs/iced/0.13.1/iced/widget/text/enum.Shaping.html#variant.Advanced"><code>Shaping::Advanced</code></a>,
but text editing for these scripts is not yet supported; and neither are <a href="https://en.wikipedia.org/wiki/Input_method">Input Method Editors</a>.</p>
<p>These features are in the <a href="https://whimsical.com/roadmap-iced-7vhq6R35Lp3TmYH4WeYwLM"><code>ROADMAP</code></a>, however!</p>
<h2 id="when-are-the-view-and-subscription-functions-called"><a class="header" href="#when-are-the-view-and-subscription-functions-called">When Are the <code>view</code> and <code>subscription</code> Functions Called?</a></h2>
<p>After every batch of messages and <code>update</code> calls. But this is an implementation detail;
and should never rely on this.</p>
<p>Try to treat these functions as declarative, stateless functions.</p>
<h2 id="does-iced-redraw-all-the-time"><a class="header" href="#does-iced-redraw-all-the-time">Does Iced Redraw All the Time?!</a></h2>
<p>Yes! iced currently redraws after every runtime event; including tiny mouse movements.</p>
<p>There are plans to redraw less frequently by detecting widget state changes, but performance has not
been a priority so far.</p>
<p>The renderers do perform quite a lot of caching; so redrawing is quite cheap. As a result,
this is rarely an issue for most use cases!</p>
<h2 id="i-am-getting-a-panic-saying-there-is-no-reactor-running-what-is-going-on"><a class="header" href="#i-am-getting-a-panic-saying-there-is-no-reactor-running-what-is-going-on">I Am Getting A Panic Saying There Is No Reactor Running. What Is Going On?</a></h2>
<p>You are probably using <code>Task</code> to execute a <code>Future</code> that needs the <code>tokio</code> executor:</p>
<pre><code class="language-text">there is no reactor running, must be called from the context of a Tokio 1.x runtime
</code></pre>
<p>You should be able to fix this issue by enabling <a href="https://docs.rs/crate/iced/latest/features#tokio">the <code>tokio</code> feature flag</a> in the <code>iced</code> crate:</p>
<pre><code class="language-toml">iced = { version = "0.13", features = ["tokio"] }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
